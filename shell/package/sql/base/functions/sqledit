# ZSH function file
# Part of the SQL base package
# Edit the data in a table
# Usage: sqledit <table>
#

eval $_sql_intro

if (( ARGC != 1 ))
then
  echo "Syntax: sqledit <table>"
fi

# Get table name and list of columns for it
local table="$argv[1]"
local columns="_sql_columns_$table"
_sql_get_column_names $table

if (( ! ${(P)#columns} ))
then
  echo "Table does not exist: $table" 1>&2
  return 1
fi

# Set up state
local tmpbase="${TMPPREFIX:-/tmp/zsh}.$$.$table.$RANDOM"
local editor="${VISUAL:-${EDITOR:-vi}}"

# If using emacs then see if the user wants to use Emacs forms mode to edit
# the table a record at a time
integer useforms=0
if [[ $editor == *emacs* ]]
then
  echo
  echo "Use Emacs forms for editing? (y/N)"
  if read -q
  then
    useforms=1
    echo "Using forms edit mode"
  else
    echo "Using standard edit mode"
  fi
fi

# Copy table into file
echo
echo "Reading table..."
sqlbcp $table out $tmpbase.dat

# Start the editor as appropriate
echo
echo "Starting editor..."
if (( useforms ))
then

  # We are using the Emacs forms mode, so write a control file to set it up

  # Calculate maximum column name width for formatting later
  integer length=0
  local column=""
  for column in ${(P)columns}
  do
    (( $#column > length )) && length=$#column
  done

  # First output the header
  {
    cat <<EOF
;; -*- forms -*- AUTO GENERATED by sqledit

;; Define special exit function to correctly save buffers & notify client
(defun forms-server-done-and-exit (query)
  "Normal exit from Forms mode when invoked from an emacsclient
session. Modified buffers are saved and clients are informed."
  (interactive "P")
  (server-buffer-done (current-buffer))
  (forms-exit query))

;; Ensure forms keymaps have been created, then make them local
(if forms-mode-map
    nil
  (forms--mode-commands))
(make-local-variable 'forms-mode-map)
(make-local-variable 'forms-mode-ro-map)
(make-local-variable 'forms-mode-edit-map)

;; Redefine exit keys to use our function
(define-key forms-mode-map "\C-x" 'forms-server-done-and-exit)
(define-key forms-mode-ro-map "x" 'forms-server-done-and-exit)

;; Standard forms setup
(setq forms-file "$tmpbase.dat")
(setq forms-number-of-fields ${(P)#columns})
(setq forms-format-list
      (list
"Editing table $table:

EOF
    # ' # Just to unconfuse emacs colouring

    # Write out a line for each column
    integer count=1
    for column in ${(P)columns}
    do
      local -L $length header="$column"
      echo "$header: \" $count \""
      (( count++ ))
    done

    # Finish it off
    echo "\"))"
  } > $tmpbase.form

  # Invoke Emacs on the form file
  $editor $tmpbase.form
else

  # Invoke the editor on the data file
  $editor $tmpbase.dat
fi

# Check to see if the user wants to write the changes
echo
echo "Write changes to database? (y/N)"
if read -q
then
  # If so then delete the current contents of the table and write the new ones
  if sql delete from $table &&
       sqlbcp $table in $tmpbase.dat
  then
    echo
    echo "Changes written ok"
  else
    echo
    echo "ERROR: Failed while writing changes. Table may be corrupt"
    mv $tmpbase.dat $tmpbase.preserve
    echo "ERROR: (Data saved in file $tmpbase.preserve for recovery)"
  fi
else
  echo "Changes not written"
fi

# Tidy up temporary files
rm -f $tmpbase.dat $tmpbase.form
