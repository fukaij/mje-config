# ZSH function file
# Part of the prompt package
# Hook for preexec function
# Usage: _prompt_precmd
#
# $Id: _prompt_preexec,v 1.10 2001/03/19 18:21:28 mebourne Exp $

local command="$1"

# Calculate the number of rows used by the command line (including left prompt).
# Note that the combined line is split into logical rows according to any
# incorporated newlines, and these are summed up individually
local lastrow lastrows=0 rows=0
for lastrow in "${(f)${(%%)${PROMPT//[%]\{[^%]#%\}/}}}${(f)command}"
do
  (( lastrows = 1 + $#lastrow / COLUMNS ))
  (( rows += lastrows ))
done

# Move up the required number of rows to get to the start of the command line
repeat $rows
do
  echotc up
done

# Modify command to put a clear to end of line before each newline incorporated.
# This is in case there were any secondary prompts midway, helps remove the
# clutter, though not guaranteed to be perfect
command=${command//$'\n'/$(echotc ce)$'\n'}


## Redraw the command line

# First the left prompt
echotc cr
echo -n - "${(%%)PROMPT}"

# Then the command in bold. Don't let echo parse any escape sequences in command
echo -n - "$prompt_colour_start$prompt_colours[bold]$prompt_colour_end"
echo -nE - "$command"
echo -n - "$prompt_colour_start$prompt_colours[normal]$prompt_colour_end"

# Then the padding to right justify the right prompt. Only use last logical row of
# command for this calculation
echo -n - "$_prompt_gap[$[ $#lastrow
                         + ${#${(%%)${prompt_right//[%]\{[^%]#%\}/}}} - COLUMNS * lastrows ],-1]"

# Then the right prompt
echo -n - "${(%%)prompt_right}"

# May need a newline depending on terminal
if [[ $(echotc am 2>/dev/null) != yes || $(echotc xn 2>/dev/null) == yes ]]
then
  echo
fi
