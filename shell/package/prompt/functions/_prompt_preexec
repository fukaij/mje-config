# ZSH function file
# Part of the prompt package
# Hook for preexec function
# Usage: _prompt_precmd
#
# $Id: _prompt_preexec,v 1.13 2001/05/09 16:45:20 mebourne Exp $

local command="$1"

if (( COLUMNS != _prompt_columns ))
then
  _prompt_winch
fi

# Calculate the number of rows used by the command line (including left prompt).
# Note that the combined line is split into logical rows according to any
# incorporated newlines, and these are summed up individually
local lastrow lastrows=0 rows=0
for lastrow in "${(f)${(%%)${PROMPT//[%]\{[^%]#%\}/}}}${(f)command}"
do
  (( lastrows = 1 + $#lastrow / COLUMNS ))
  (( rows += lastrows ))
done

# Move up the required number of rows to get to the start of the command line
repeat $rows
do
  echotc up
done

# Modify command to put a clear to end of line before each newline incorporated.
# This is in case there were any secondary prompts midway, helps remove the
# clutter, though not guaranteed to be perfect
command=${command//$'\n'/$_prompt_clearline$'\n'}


## Redraw the command line

# First the left prompt
echotc cr
echo -n - "${(%%)PROMPT}"

# Then the command in bold. Don't let echo parse any escape sequences in command
echo -n - "$colour_start$colours[bold]$colour_end"
echo -nE - "$command"
echo -n - "$colour_start$colours[normal]$colour_end"

# Then the padding to right justify the right prompt. Only use last logical row of
# command for this calculation
echo -n - "$_prompt_gap[$[ $#lastrow
                         + ${#${(%%)${prompt_right//[%]\{[^%]#%\}/}}} - COLUMNS * lastrows ],-1]"

# Then the right prompt
echo -n - "${(%%)prompt_right}"

# May need a newline depending on terminal
if (( _prompt_wrapmode ))
then
  echo
fi
