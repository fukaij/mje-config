# ZSH function file
# Provide options parsing and help output
# Usage: parse_opts <argv> <results> [<help>]
#
# $Id: parse_opts,v 1.1 2001/07/30 18:32:41 mebourne Exp $

# This helper function takes an encoded helpstring as its only parameter and
# generates the option_types, option_shortnames, and option_longnames
# associative arrays, and option_helptext string
# The option descriptions are of the form:
#   # [ <name> '=' ] <option> [ '|' <option> ] ... [ '=' <type> ]
# type is currently switch or string, default of switch
_parse_opts_parsehelp() {
  local -a paraminfo helptext

  # Process each line in the helptext
  local line
  for line in ${(f)argv[1]}
  do
    # If it starts with a '#' then its an option description line
    if [[ $line == [$IFS]#\#* ]]
    then
      # Decode the description line into fields
      paraminfo=(${=line})
      shift paraminfo

      # Get the true name for this option. If not of the form 'name = option'
      # then just re-use the first option name for it
      local name="$paraminfo[1]"
      if [[ $paraminfo[2] == '=' ]]
      then
	shift paraminfo
	shift paraminfo
      fi

      # Read off all of the aliases for the option until an '='
      while [[ $#paraminfo -ne 0 && $paraminfo[1] != '=' ]]
      do
	if [[ $paraminfo[1] != '|' ]]
	then
	  # Store alias in short (single character) or long name map as appropriate
	  if [[ $paraminfo[1] == ? ]]
	  then
	    option_shortnames[$paraminfo[1]]=$name
	  else
	    option_longnames[$paraminfo[1]]=$name
	  fi
	fi
	shift paraminfo
      done

      # Decode the type if provided '= type'. Default to switch
      local type="switch"
      if [[ $paraminfo[1] == '=' ]]
      then
	type=$paraminfo[2]
      fi
      option_types[$name]=$type
    else
      # Doesn't start with a # so append it to help
      helptext=($helptext $line)
    fi
  done

  # Create the help string from the array of lines. In order to get a blank
  # line this far it must have a space on it
  option_helptext=(${(F)helptext})
}

# This helper function decodes the command line arguments using the
# pre-generated option arrays from option_parsehelp. Arguments are provided in
# option_argv and are removed as and when processed. Decoded options are
# returned in option_results. Returns 1 if an error prevented the options from
# being processed, else 0
_parse_opts_decode() {
  # Process each argument while it is an option
  while [[ $option_argv[1] == -* ]]
  do
    local option="$option_argv[1]"

    # First check if it is a long argument
    if [[ $option == --* ]]
    then

      # Extract the option name from eg. --name=value
      local name="${${option#--}%%\=*}"

      # Check to see if the option exists
      if [[ -n $option_longnames[$name] ]]
      then
        local realname="$option_longnames[$name]" value=1

	# Behave according to the type of the option
	case $option_types[$realname] in
	  switch) # Simple switch. Mark its presence
	    value=1
	    ;;

	  string) # Takes a parameter

	    # Check to see if parameter was in option, ie. --name=value
	    if [[ $option == *=* ]]
	    then
	      value="${option#*=}"
	    else

	      # Otherwise grab the next argument for it
	      shift option_argv; value=$option_argv[1]
	    fi
	    ;;

	  *) # This is a configuration error
	    echo "Invalid option type: $option_types[$realname]" 1>&2
	    return 1
	    ;;
	esac

	# Store the value against the real option name
	option_results[$realname]=$value
      else
        echo "Invalid option: $name" 1>&2
	return 1
      fi

    # Wasn't a long argument, try short one (may be grouped)
    elif [[ $option == -?* ]]
    then

      # Extract the list of options from eg. -jkl
      local optiongroup="${option#-}"

      # Process each letter individually
      while [[ -n $optiongroup ]]
      do
        # Extract the first letter
        local optionletter="$optiongroup[1]"
	optiongroup=${optiongroup#?}

        # Check to see if is a valid short option
        if [[ -n $option_shortnames[$optionletter] ]]
        then
          local realname="$option_shortnames[$optionletter]" value=1

	  # Behave according to the type of the option
          case $option_types[$realname] in
	    switch) # Simple switch. Mark its presence
	      value=1
	      ;;

	    string) # Takes a parameter

              # Get the next argument as the parameter. Note that if options
              # taking a parameter are grouped, then the parameters follow
              # straight afterwards in the respective order
	      shift option_argv; value=$option_argv[1]
	      ;;

	    *) # This is a configuration error
	      echo "Invalid option type: $option_types[$realname]" 1>&2
	      return 1
	      ;;
          esac

          # Store the value against the real option name
          option_results[$realname]=$value
        else
          echo "Invalid option: $optionletter" 1>&2
          return 1
        fi
      done
    else
      # Must be a lone -
      echo "Missing option after -" 1>&2
      return 1
    fi
    shift option_argv
  done
}

# This helper function controls the overall processing
_parse_opts_process() {
  local -A option_longnames option_shortnames option_types
  local option_helptext

  # Check for arguments. If we have one and it is not '-' then it is the help
  # string. Otherwise need to to get that from stdin
  local config
  if [[ -n $argv[1] && $argv[1] != - ]]
  then
    config=$argv[1]
  else
    config=$(cat)
  fi

  # Parse the help string we've got to determine the type of options
  _parse_opts_parsehelp $config

  # Perform the argument decoding
  if _parse_opts_decode
  then

    # If success and help was requested then give it. Note that it is up to
    # the user to supply the help option before we can use it
    if [[ -n $option_results[help] ]]
    then
      echo "Usage: $option_helptext"
      return 1
    fi
  else

    # There was an error in processing. Mention the --help option. Assumes the
    # function supplied one!
    echo "Use --help for more information" 1>&2
    return 1
  fi

  return 0
}

# Parse the command line arguments to extract both long and short form options
# Usage: parse_opts <argv> <results> [<help>]
# argv    - The NAME of the array that the arguments have been copied into. Note
#           that they must have been copied; 'argv' cannot be passed here
# results - The NAME of the associative array that the decoded options are to be
#           placed in
# help    - The help text with the option descriptions encoded in it. If not
#           provided then this will be read from stdin (this allows the use of
#           a here-doc to provide the help)
# Returns 1 if an error occurred or help was given, 0 for success. If 1 is
# returned then no further action is required - it has already been reported.
# Also the source arrays will remain unchanged in this case.
parse_opts() {

  # This function is a wrapper for _parse_opts_process. This is so that when we
  # access the arrays in the calling function's namespace, we don't have all
  # our local variables to potentially clash with

  local external_argv="$argv[1]" external_results="$argv[2]" parse_opts_config="$argv[3]"

  local -a option_argv
  local -A option_results
  option_argv=(${(P)external_argv})

  # Do the work. Only update the source arrays if we succeeded
  if _parse_opts_process $parse_opts_config
  then
    eval $external_argv='($option_argv)'
    eval $external_results='(${(kv)option_results})'
  else
    return 1
  fi
}

parse_opts "$argv[@]"
