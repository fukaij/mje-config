# ZSH function file
# Provide options parsing and help output
# Usage: parse_opts <argv> <results> [<help>]
#
# $Id: parse_opts,v 1.11 2001/08/02 15:58:08 mebourne Exp $

### Documentation


# todo
# optional params
# constant hash tags
# args completion

# This module provides a complete option parsing system, configured entirely
# from a help string supplied by the user. The help string is free-format text
# and describes options in the usual way; into this is then embedded special
# option descriptions which this module decodes to allow it to process the
# command line arguments.
#
# Both standard Unix single character options (which may be grouped, eg. -a -l
# or -al), and GNU style long options (eg. --long-list) are supported, and
# parameters provided with an option may be type checked. Parameters are
# recognised in a variety of formats for the user's convenience.
# eg.
#   -d <dir>
#   --directory=<dir>
#   --directory <dir>
#
# ...more text here...
#
# The option descriptions are of the form:
#   `# ' [ <tag> ( ` = ' | ` += ' ) ] [ `[' <frequency> `]' ] <option> [ ` | ' <option> ] ... [ ` : ' <type> ]
#
# tag is of the form:
#   `[' <key-name> `]'
# or
#   <variable-name>
#
# Where key-name is the name of the hash key the value will be stored in. The
# alternative of variable-name stores the value directly in the given
# variable. The variable is expected to be local to the calling program, and
# the exact behaviour depends on its type:
#   undefined/scalar  - value stored directly
#   array             - value appended to array
#   associative array - value stored against a key of the option name (without leading `-'s)
#
# If tag is not supplied, then the first <option> value will be re-used as key-name.
#
# option is of the form:
#   <option-name>
#
# Where option-name is the name the option will be passed as when invoked by
# the user. Single letter options are introduced by `-', and may be grouped.
# Other options are long options introduced by `--'. If there is no `-' at the
# start of the option name then this is taken to be an argument definition
#
# frequency is of the form:
#   <count>
# or
#   <min-count> `,' <max-count>
#
# count, min-count, max-count are of the form:
#   <integer>
# or
#   `*'
# or
#   `*-' <integer>
#
# Where integer is a positive integer.
#
# type is of the form:
#   <type-name> [ `=' <value> ]
#
# Where type-name is one of:
#   switch   - Simple switch. Result will be 1. NB. This is the default if not supplied
#   noswitch - Reverse simple switch. Result will be 0 (can be used eg. --no-option)
#   constant - Constant to be assigned. Result will be value given, with any quotes removed
#   string   - Takes a parameter with no validation
#   integer  - Takes a parameter, validation for integer with optional sign
#   test     - Takes a parameter, validation using value with test. eg. test=-f for files
#
# value may only be (and must be) present if the type requires it, and will be
# used as explained in the type description.


### Implementation

# NB. In some of the below functions (marked) locals must begin with _po_.
# This is to prevent name clashes when options refer back to variables in the
# calling program's name space

# This helper function takes an encoded helpstring as its only parameter and
# generates the _po_tags, _po_types, _po_aliases, and _po_helplines
# associative arrays, and _po_helptext string
_parse_opts_parsehelp() {
  local -a helptext

  # Process each line in the helptext. Note double newline (ie. empty line) is
  # converted to have a space so it doesn't get lost in the splitting
  local line helpline
  local -a paraminfo
  for line in ${(@f)argv[1]//$'\n\n'/$'\n \n'}
  do

    # If it starts with a '#' then its an option description line
    if [[ $line == [[:blank:]]#\#* ]]
    then
      # Decode the description line into fields. Use 'z' not '=' to get proper quote handling
      paraminfo=(${(z)line})
      shift paraminfo

      # Extract the type information if there is any
      local type=""
      if (( paraminfo[(I):] ))
      then
        type=$paraminfo[paraminfo[(I):]+1,-1]
	paraminfo=($paraminfo[1,paraminfo[(I):]-1])
      fi

      # Extract the tag information if there is any
      local tag=""
      if (( paraminfo[(I)(+|)=] ))
      then
        tag=$paraminfo[1,paraminfo[(I)(+|)=]-1]
	if [[ $paraminfo[(r)(+|)=] == += ]]
	then
	  tag="+$tag"
	fi
	paraminfo=($paraminfo[paraminfo[(I)(+|)=]+1,-1])
      fi

      # Handle the optional frequency definition
      # (default is [1] for arguments, [0,1] for options)
      local frequency=""
      if [[ $paraminfo[1] == \[*\] ]]
      then
        frequency=${${paraminfo[1]#\[}%\]}
	shift paraminfo
      fi

      # Options is remainder less the '|'
      paraminfo=(${paraminfo:#\|})

      # Check we've got something left
      if (( !$#paraminfo ))
      then
        echo "Missing option/argument name in definition: '" $=line "'" 1>&2
	return 1
      fi

      # If tag not provided then default to first option name with any leading '-'s removed
      if [[ -z $tag ]]
      then
        tag="[${paraminfo[1]##-#}]"
      fi

      # Assign all the details for the current options/argument
      local option=""
      for option in $paraminfo
      do
        local aliases="" excludes=""

        # Establish defaults for missing values
        if [[ $option == -* ]]
	then
	  [[ -z $frequency ]] && frequency="0,1"
	  [[ -z $type ]] && type="switch"

	  # Aliases, excluding this option
	  aliases=${paraminfo:#$option}

	  # Excludes. Only if the max frequency of this option is 1, same as aliases
          integer min_frequency=0 max_frequency=0
          _parse_opts_minmaxfrequency min_frequency max_frequency -1 $frequency || return 1
          if (( max_frequency == 1 ))
          then
            excludes=$aliases
          fi

	else
	  [[ -z $frequency ]] && frequency="1"
	  [[ -z $type ]] && type="string"
	fi

	# Report info on option if debugging enabled
        if (( _po_debug ))
	then
	  echo "option = '$option' {"
	  echo "  tag       = '$tag'"
	  echo "  frequency = '$frequency'"
	  echo "  type      = '$type'"
	  echo "  help      = '$helpline'"
	  echo "}"
	fi

	# Store the main data for this option
        _po_tags[$option]=$tag
	_po_frequencies[$option]=$frequency
        _po_types[$option]=$type
	_po_helplines[$option]=$helpline
 	_po_excludes[$option]=$excludes

	# If its an option then store its aliases in _po_aliases, else store
	# the option name in _po_arguments. Thus this is how they can be
	# distinguished from each other (in addition to checking for '-')
	if [[ $option == -* ]]
	then
  	  _po_aliases[$option]=$aliases
	else
  	  _po_arguments=($_po_arguments $option)
	fi
      done
    else
      # Doesn't start with a # so append it to help
      helptext=($helptext $line)

      # If we have a line which has non-whitespace before any tabs it's an
      # option or argument or something similar. So we reset our current
      # helpline because the description will come after it
      if [[ $line == \ #[[:graph:]]*$'\t'* ]]
      then
        helpline=""
      fi

      # If the line has a tab on it then it might have a description after the tab
      if [[ $line == *$'\t'* ]]
      then
        # Extract the text after any tabs, and trim it of whitespace
        line=${${line##*$'\t'[[:blank:]]#}%%[[:blank:]]}
	if [[ -n $line ]]
	then
	  # Add to current helpline
	  if [[ -n $helpline ]]
	  then
	    helpline="$helpline $line"
	  else
	    helpline=$line
	  fi
	fi
      fi
    fi
  done

  # Create the help string from the array of lines. In order to get a blank
  # line this far it must have a space on it
  _po_helptext=(${(F)helptext})

  # Useful for debugging
  if (( _po_debug ))
  then
    echo "_po_tags=(${(qqkv)_po_tags[@]})"
    echo "_po_frequencies=(${(qqkv)_po_frequencies[@]})"
    echo "_po_types=(${(qqkv)_po_types[@]})"
    echo "_po_aliases=(${(qqkv)_po_aliases[@]})"
    echo "_po_excludes=(${(qqkv)_po_excludes[@]})"
    echo "_po_helplines=(${(qqkv)_po_helplines[@]})"
    echo "_po_arguments=($_po_arguments)"
  fi

  return 0
}

# This function decodes the numeric expression within a frequency
# specification to return an integer value. The variable given to var will be
# updated with the results of processing the given expression substituting
# number for `*'
_parse_opts_frequencyvalue() {
  local var="$argv[1]"
  integer number="$argv[2]"
  local expression="$argv[3]"

  integer result=0
  case $expression in
    \*) # Use default number
      result=$number
      ;;

    <->) # Use fixed number
      result=$expression
      ;;

    \*-<->) # Use default number minus fixed number
      (( result = number - ${expression#\*-} ))
      ;;

    *) # This is a configuration error
      echo "Unrecognised frequency: '$expression'" 1>&2
      return 1
      ;;
  esac

  eval $var=$result

  return 0
}

# This function decodes a frequency expression into min and max values. The
# variables given to minvar & maxvar will be updated with the results of
# processing the given expression substituting number for `*'
_parse_opts_minmaxfrequency() {
  local minvar="$argv[1]" maxvar="$argv[2]"
  integer number="$argv[3]"
  local expression="$argv[4]"

  case $expression in
    *,*) # Separate min & max values
      _parse_opts_frequencyvalue $minvar $number ${expression%,*} || return 1
      _parse_opts_frequencyvalue $maxvar $number ${expression#*,} || return 1
      ;;

    *) # Min & max values the same
      _parse_opts_frequencyvalue $minvar $number $expression || return 1
      _parse_opts_frequencyvalue $maxvar $number $expression || return 1
     ;;
  esac

  return 0
}

# This function generates the _arguments call used by the completion system.
# It is called when the special option --zsh-completion is passed on the
# command line to the calling program. The command is written to stdout only
# on success, and the completion system will then take that and execute it. On
# error, errors are written to stderr instead. If returning the completion
# information, parse_opts always exits with 1 in order to cause the calling
# program to exit, so the return code can not be used to signal errors
_parse_opts_generatecompletion() {
  local -a specs

  # Process each option to build a list of specifications for _arguments.
  # Careful to skip our magic --zsh-completion option
  local -a aliases excludes
  local option
  for option in ${${(k)_po_aliases}:#--zsh-completion} $_po_arguments
  do
    integer isoption=0
    [[ $option == -* ]] && isoption=1

    local frequency="$_po_frequencies[$option]"
    integer min_frequency=0 max_frequency=0
    _parse_opts_minmaxfrequency min_frequency max_frequency -1 $frequency || return 1

    # Try to determine a description/completer from the type of this option
    local type="$_po_types[$option]" description="" action=""
    case $type in
      switch|noswitch|constant=*)
        # No parameters, leave blank
        ;;

      string)
        # Takes a parameter with no validation
	description="string"
	action=" "
        ;;

      integer)
        # Takes a parameter, validation for integer with optional sign
	description="integer number"
	action=" "
        ;;

      test=*)
        # Takes a parameter validated by test. Extract the test flag & try to
        # figure out the completer
        local test=${type#*=}
	case $test in
	  -[aefgkrsuwOGN]) # These are types of file
	    description="file"
	    action="_files"
	    ;;

	  -[bcdhpxLS]) # These should be special types of file but need to be looked into
	    description="file"
	    action="_files"
	    ;;

	  -[notz]) # These can't be completed
	    description="value"
	    action=" "
	    ;;

	  *) # This is not recognised
	    description="unknown"
	    action=" "
	    ;;
	esac
	;;

      *) # This is a configuration error
        echo "Invalid option type for option $option: '$type'" 1>&2
        return 1
	;;
    esac


    local spec=""

    if (( isoption ))
    then

      # Generate excludes clause if we have any
      if [[ -n $_po_excludes[$option] ]]
      then
	spec="$spec($_po_excludes[$option])"
      fi

      # Add repeating option flag if max frequency is not 1
      if (( max_frequency != 1 ))
      then
    	spec="$spec*"
      fi

      # Add the main option name section
      spec="$spec$option"

      # If we have a long option which takes a parameter then add the '=' flag
      # to say --option=value is valid
      if [[ $option == --* && -n $action ]]
      then
	spec="$spec="
      fi

      # Add the description of the option if one was successfully extracted from the help text
      if [[ -n $_po_helplines[$option] ]]
      then
	spec="${spec}[$_po_helplines[$option]]"
      fi

      # Now add the description and completer for the parameter, if we have one
      if [[ -n $action ]]
      then
	spec="$spec:$description:$action"
      fi

      # Collect the specifications
      specs=($specs "'$spec'")

    else

      if (( min_frequency < 0 || max_frequency < 0 ))
      then
        spec="$spec*"
      fi

      spec="$spec:$description"

      # Add the description of the argument if one was successfully extracted from the help text
      if [[ -n $_po_helplines[$option] ]]
      then
        spec="$spec - $_po_helplines[$option]"
      fi

      spec="$spec:$action"

      # Collect the specifications
      if (( min_frequency < 0 || max_frequency < 0 || min_frequency > max_frequency ))
      then
        specs=($specs "'$spec'")
      else
        repeat $min_frequency
	do
          specs=($specs "'$spec'")
	done
        repeat $(( max_frequency - min_frequency ))
	do
          specs=($specs "':$spec'")
	done
      fi
    fi
  done

  # Only output the _arguments call on success
  # -s - Allow option grouping for single letter options
  # -w - Arguments follow single letter options, one for each relevant option
  # -S - Handle -- to terminate options
  # -A - No more options after first non-option argument
  echo "_arguments -s -w -S -A '-*' $specs"

  return 0
}

# This helper function stores the given value against the given option name,
# as defined by its related tag
_parse_opts_store() {
  local _po_name="$argv[1]" _po_value="$argv[2]"

  # If tag is of the form [var] then instead assign to real variable.
  # Note possibility of clashes with our local variables here
  local _po_tag="$_po_tags[$_po_name]"

  integer append=0
  if [[ $_po_tag == +* ]]
  then
    append=1
    _po_tag=${_po_tag#+}
  fi

  case $_po_tag in
    \[*\]) # Store in the default options associative array
      _po_tag=${${_po_tag#\[}%\]}
      if (( append && $#_po_results[$_po_tag] ))
      then
        _po_results[$_po_tag]="$_po_results[$_po_tag] $_po_value"
      else
        _po_results[$_po_tag]=$_po_value
      fi
      ;;

    *) # Store in external variable/array

      # Behave according to the type of the external variable
      case ${(Pt)_po_tag} in
    	array*)
    	  # An array
	  if (( append ))
	  then
	    eval $_po_tag='("${(@P)_po_tag}" "$_po_value")'
	  else
	    eval $_po_tag='("$_po_value")'
	  fi
	  ;;

    	association*)
    	  # An associative array. Add option/value pair
	  local _po_oldvalue
	  eval _po_oldvalue="\$${_po_tag}[$_po_name]"
	  if (( append && $#_po_oldvalue ))
	  then
	    eval $_po_tag\[\$_po_name\]='"$_po_oldvalue $_po_value"'
	  else
	    eval $_po_tag\[\$_po_name\]='$_po_value'
	  fi
	  ;;

    	*)
    	  # Some kind of scalar or undefined
	  if (( append && ${(P)#_po_tag} ))
	  then
	    eval $_po_tag='"${(P)_po_tag} $_po_value"'
	  else
	    eval $_po_tag='$_po_value'
	  fi
    	  ;;
      esac
  esac

  return 0
}

# This helper function for _parse_opts_handletype gets the next value for an
# option. It uses local variables in _parse_opts_handletype and so should not
# be called from elsewhere
_parse_opts_getnextvalue() {
  if (( _po_hasgivenvalue ))
  then
    # Value supplied with option so use that one first
    _po_value=$_po_givenvalue
    _po_hasgivenvalue=0
  else
    # Get the next argument as the value. Note that if single letter options
    # taking a parameter are grouped, then the parameters follow straight
    # afterwards in the respective order

    # Check there's a value to get
    if (( $#_po_argv ))
    then
      _po_value=$_po_argv[1]
      shift _po_argv
    else
      echo "Missing parameter to option '$name'" 1>&2
      return 1
    fi
  fi

  return 0
}

# This helper function handles processing of the option type. Any values it
# needs will be fetched vie _parse_opts_getnextvalue, and the appropriate
# result variable will be updated. Any validation of the values is also
# performed here
#
# NB. Locals in this function must begin _po_
_parse_opts_handletype() {
  local _po_name="$argv[1]" _po_hasgivenvalue="$argv[2]" _po_givenvalue="$argv[3]"

  local _po_type="$_po_types[$_po_name]" _po_value
  case $_po_type in
    switch)
      # Simple switch. Mark its presence
      _po_value=1
      ;;

    noswitch)
      # Reverse simple switch. Mark its presence
      _po_value=0
      ;;

    constant=*)
      # Constant to be assigned (after quote removal). eg. constant=value or constant="more values"
      _po_value=${(Q)_po_type#*=}
      ;;

    string)
      # Takes a parameter with no validation
      _parse_opts_getnextvalue || return
      ;;

    integer)
      # Takes a parameter, validation for integer with optional sign
      _parse_opts_getnextvalue || return
      if [[ $_po_value != ([-+]|)<-> ]]
      then
        echo "Invalid value for option $_po_name: '$_po_value'" 1>&2
	return 1
      fi
      ;;

    test=*)
      # Takes a parameter, validation using test. eg. test=-f
      _parse_opts_getnextvalue || return
      if eval "[[ ! ${_po_type#*=} \$_po_value ]]"
      then
        echo "Invalid value for option $_po_name: '$_po_value'" 1>&2
	return 1
      fi
      ;;

    *) # This is a configuration error
      echo "Invalid option type for option $_po_name: '$_po_type'" 1>&2
      return 1
      ;;
  esac

  _parse_opts_store $_po_name $_po_value
}

# This helper function decodes any options present in the command line
# arguments, using the pre-generated option arrays from _parse_opts_parsehelp.
# Arguments are provided in _po_argv and are removed as and when processed.
# Decoded options are returned in _po_results. Returns 1 if an error prevented
# the options from being processed, else 0
#
# NB. Locals in this function must begin _po_
_parse_opts_dooptions() {

  # Process each argument while it is an option
  while [[ $_po_argv[1] == -* ]]
  do
    local _po_option="$_po_argv[1]"
    shift _po_argv

    case $_po_option in
      --) # End of option list

        # Nothing else to do - return success
        return 0
	;;

      --*) # Long argument

      	# Check to see if the option exists
      	if (( $+_po_aliases[$_po_option] ))
      	then

	  # Check to see if value was in option, ie. --name=value
	  if [[ $_po_option == *=* ]]
	  then

	    # Extract value in option and pass to type processing
	    _parse_opts_handletype $_po_option 1 ${_po_option#*=} || return
	  else

	    # Call type handling without a value
	    _parse_opts_handletype $_po_option 0 || return
	  fi
      	else
      	  echo "Invalid option: $_po_option" 1>&2
	  return 1
      	fi
	;;

      -?*) # Short option (may be grouped)

      	# Extract the list of options from eg. -jkl
      	local _po_optiongroup="${_po_option#-}"

      	# Process each letter individually
      	while [[ -n $_po_optiongroup ]]
      	do
      	  # Extract the first letter
      	  local _po_optionletter="$_po_optiongroup[1]"
	  _po_optiongroup=${_po_optiongroup#?}

      	  # Check to see if is a valid short option
      	  if (( $+_po_aliases[-$_po_optionletter] ))
      	  then

	    # It is so process it as the type determines
	    _parse_opts_handletype -$_po_optionletter 0 || return
      	  else
      	    echo "Invalid option: -$_po_optionletter" 1>&2
      	    return 1
      	  fi
      	done
	;;

      *) # Must be a lone -
        echo "Missing option after -" 1>&2
        return 1
	;;
    esac
  done

  return 0
}

# This helper function decodes any arguments present in the command line after
# the options have been removed, using the pre-generated option arrays from
# _parse_opts_parsehelp. Arguments are provided in _po_argv and are removed as
# and when processed. Decoded values are returned in _po_results. Returns 1 if
# an error prevented the arguments from being processed, else 0
#
# NB. Locals in this function must begin _po_
_parse_opts_doarguments() {

  # Process each argument specification
  local _po_argument
  for _po_argument in $_po_arguments
  do
    local _po_frequency="$_po_frequencies[$_po_argument]"

    # Ensure number of args to use is within required range
    integer _po_use=$#_po_argv _po_min=0 _po_max=0
    _parse_opts_minmaxfrequency _po_min _po_max $_po_use $_po_frequency || return 1
    if (( _po_use > _po_max ))
    then
      _po_use=$_po_max
    elif (( _po_use < _po_min ))
    then
      _po_use=$_po_min
    fi

    # Check there are a sufficient number of arguments left
    if (( $#_po_argv >= _po_use ))
    then

      # Process each of them according to the type
      repeat $_po_use
      do
        _parse_opts_handletype $_po_argument 1 $_po_argv[1] || return
	shift _po_argv
      done
    else
      echo "Insufficient arguments" 1>&2
      return 1
    fi
  done

  # If there's any surplus arguments that's an error
  if (( $#_po_argv ))
  then
    echo "Too many arguments" 1>&2
    return 1
  fi

  return 0
}

# This helper function controls the overall processing
#
# NB. Locals in this function must begin _po_
_parse_opts_process() {
  local -a _po_arguments
  local -A _po_tags _po_frequencies _po_types _po_aliases _po_excludes _po_helplines
  local _po_helptext

  # Check for arguments. If we have one and it is not '-' then it is the help
  # string. Otherwise need to to get that from stdin
  local _po_config
  if [[ -n $argv[1] && $argv[1] != - ]]
  then
    _po_config=$argv[1]
  else
    _po_config=$(cat)
  fi

  # Parse the help string we've got to determine the type of options
  _parse_opts_parsehelp $_po_config || return 1

  # Add hooks for zsh completion system
  _po_tags[--zsh-completion]="[zshcompletion]"
  _po_types[--zsh-completion]="switch"
  _po_aliases[--zsh-completion]=""

  # Perform the option recognition
  if _parse_opts_dooptions
  then

    # If success and help was requested then give it. Note that it is up to
    # the user to supply the help option before we can use it
    if (( _po_results[help] ))
    then
      echo $_po_helptext
      return 1
    fi

    # Entry point for automatic zsh completion. We always return 1 in order to
    # get the calling program to exit. The completion system knows this is not
    # an error
    if (( _po_results[zshcompletion] ))
    then
      _parse_opts_generatecompletion
      return 1
    fi

    # Perform the argument recognition
    if ! _parse_opts_doarguments
    then

      # There was an error in processing. Mention the --help option. Assumes the
      # function supplied one!
      echo "Use --help for more information" 1>&2
      return 1
    fi

  else

    # There was an error in processing. Mention the --help option. Assumes the
    # function supplied one!
    echo "Use --help for more information" 1>&2
    return 1
  fi

  return 0
}

# Parse the command line arguments to extract both long and short form options
# Usage: parse_opts <help> <results> <argv>
# argv    - The NAME of the array that the arguments have been copied into. Note
#           that they must have been copied; 'argv' cannot be passed here
# results - The NAME of the associative array that the decoded options are to be
#           placed in
# help    - The help text with the option descriptions encoded in it. If not
#           provided then this will be read from stdin (this allows the use of
#           a here-doc to provide the help)
# Returns 1 if an error occurred or help was given, 0 for success. If 1 is
# returned then no further action is required - it has already been reported.
# Also the source arrays will remain unchanged in this case.
#
# This function is a wrapper for _parse_opts_process to handle accessing the
# arrays in the calling function's namespace
#
# NB. Locals in this function must begin _po_
parse_opts() {

  # Ensure options are in a known & useful state
  emulate -L zsh
  setopt extended_glob

  # Extract arguments passed to us
  local _po_ext_results _po_ext_argv _po_config
  [[ $argv[1] != -- ]] && _po_config=$argv[1] && shift
  [[ $argv[1] != -- ]] && _po_ext_results=$argv[1] && shift
  [[ $argv[1] != -- ]] && _po_ext_argv=$argv[1] && shift
  [[ $argv[1] == -- ]] && shift

  # Copy any current values of external arrays into our copies. This allows for
  # default state in the options, etc.
  local -a _po_argv
  local -A _po_results
  _po_argv=("$argv[@]")
  [[ -n $_po_ext_argv ]] && _po_argv=("${(@P)_po_ext_argv}")
  [[ -n $_po_ext_results ]] && _po_results=("${(@Pkv)_po_ext_results}")

  # Do the work. Only update the external arrays if we succeeded and they exist
  if _parse_opts_process $_po_config
  then
    [[ -n $_po_ext_argv ]] && eval $_po_ext_argv='("$_po_argv[@]")'
    [[ -n $_po_ext_results ]] && eval $_po_ext_results='("${(@kv)_po_results}")'
  else
    return 1
  fi

  return 0
}

parse_opts "$argv[@]"
