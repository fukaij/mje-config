# ZSH function file
# Provide options parsing and help output
# Usage: parse_opts <argv> <results> [<help>]
#
# $Id: parse_opts,v 1.9 2001/08/02 09:10:15 mebourne Exp $

### Documentation


# todo
# optional params
# doc ^-$

# This module provides a complete option parsing system, configured entirely
# from a help string supplied by the user. The help string is free-format text
# and describes options in the usual way; into this is then embedded special
# option descriptions which this module decodes to allow it to process the
# command line arguments.
#
# Both standard Unix single character options (which may be grouped, eg. -a -l
# or -al), and GNU style long options (eg. --long-list) are supported, and
# parameters provided with an option may be type checked. Parameters are
# recognised in a variety of formats for the user's convenience.
# eg.
#   -d <dir>
#   --directory=<dir>
#   --directory <dir>
#
# ...more text here...
#
# The option descriptions are of the form:
#   `# ' [ <tag> ` = ' ] <option> [ ` | ' <option> ] ... [ ` = ' <type> ]
#
# tag is of the form:
#   <key-name>
# or
#   `[' <variable-name> `]'
#
# Where key-name is the name of the hash key the value will be stored in. The
# alternative of variable-name stores the value directly in the given
# variable. The variable is expected to be local to the calling program, and
# the exact behaviour depends on its type:
#   undefined/scalar  - value stored directly
#   array             - value appended to array
#   associative array - value stored against a key of the option name (without leading `-'s)
#
# If tag is not supplied, then the first <option> value will be re-used as key-name.
#
# option is of the form:
#   <option-name>
# or
#   `[' <argument-spec> `]'
#
# Where option-name is the name the option will be passed as when invoked by
# the user, without any leading `-'s. Single letter options are taken to be
# short options introduced by `-', and may be grouped. Other options are taken
# to be long options introduced by `--'. It is not possible to have a one
# character long option (eg. --a is not possible)
#
# argument-spec is of the form:
#   <count>
# or
#   <min-count> `,' <max-count>
#
# count, min-count, max-count are of the form:
#   <integer>
# or
#   `*'
# or
#   `*-' <integer>
#
# Where integer is a positive integer.
#
# type is of the form:
#   <type-name> [ `=' <value> ]
#
# Where type-name is one of:
#   switch   - Simple switch. Result will be 1. NB. This is the default if not supplied
#   noswitch - Reverse simple switch. Result will be 0 (can be used eg. --no-option)
#   constant - Constant to be assigned. Result will be value given, with any quotes removed
#   string   - Takes a parameter with no validation
#   integer  - Takes a parameter, validation for integer with optional sign
#   test     - Takes a parameter, validation using value with test. eg. test=-f for files
#
# value may only be (and must be) present if the type requires it, and will be
# used as explained in the type description.


### Implementation

# NB. In some of the below functions (marked) locals must begin with _po_.
# This is to prevent name clashes when options refer back to variables in the
# calling program's name space

# This helper function takes an encoded helpstring as its only parameter and
# generates the _po_tags, _po_types, _po_aliases, and _po_helplines
# associative arrays, and _po_helptext string
_parse_opts_parsehelp() {
  local -a helptext

  # Process each line in the helptext. Note double newline (ie. empty line) is
  # converted to have a space so it doesn't get lost in the splitting
  local line helpline
  local -a paraminfo options
  for line in ${(@f)argv[1]//$'\n\n'/$'\n \n'}
  do

    # If it starts with a '#' then its an option description line
    if [[ $line == [[:blank:]]#\#* ]]
    then
      # Decode the description line into fields. Use 'z' not '=' to get proper quote handling
      paraminfo=(${(z)line})
      shift paraminfo

      # Get the tag name for this option. If not of the form 'tag = option ...'
      # then just re-use the first option name for it
      local tag="$paraminfo[1]"
      if [[ $paraminfo[2] == '=' ]]
      then
	shift paraminfo
	shift paraminfo
      fi

      options=()
      local argument=""
      if [[ $paraminfo[1] == \[*\] ]]
      then

        # This is taken to be an argument definition

	# Argument specification comes next
        argument=$paraminfo[1]
	shift paraminfo

	# Generate internal option name of tagN
	options=("arg"$(( $#_po_arguments + 1 )))

	# If the specification is the same as the tag then 'tag =' was
	# missing, so for arguments we default to the internal option name
	if [[ $argument == $tag ]]
	then
	  tag=$options
	fi

      else

        # This is taken to be an option name

      	# Read off all of the aliases for the option until an '='
      	while [[ $#paraminfo -ne 0 && $paraminfo[1] != '=' ]]
      	do
	  if [[ $paraminfo[1] != '|' ]]
	  then
	    options=($options $paraminfo[1])
	  fi
	  shift paraminfo
      	done

      fi

      # Decode the type if provided '= type'. Default to switch
      local type="switch"
      if [[ $paraminfo[1] == '=' ]]
      then
	type=$paraminfo[2]
      fi

      # Assign all the details for the current options/argument
      local option=""
      for option in $options
      do
        _po_tags[$option]=$tag
        _po_types[$option]=$type
	_po_helplines[$option]=$helpline

	# If its an option then store its aliases in _po_aliases, else store
	# its argument specification in _po_arguments. Thus this is how then
	# can be distinguished from each other
	if [[ -z $argument ]]
	then
  	  _po_aliases[$option]=${options:#$option}
	else
  	  _po_arguments[$option]=$argument
	fi
      done
    else
      # Doesn't start with a # so append it to help
      helptext=($helptext $line)

      # If we have a line which has non-whitespace before any tabs it's an
      # option or argument or something similar. So we reset our current
      # helpline because the description will come after it
      if [[ $line == \ #[[:graph:]]*$'\t'* ]]
      then
        helpline=""
      fi

      # If the line has a tab on it then it might have a description after the tab
      if [[ $line == *$'\t'* ]]
      then
        # Extract the text after any tabs, and trim it of whitespace
        line=${${line##*$'\t'[[:blank:]]#}%%[[:blank:]]}
	if [[ -n $line ]]
	then
	  # Add to current helpline
	  if [[ -n $helpline ]]
	  then
	    helpline="$helpline $line"
	  else
	    helpline=$line
	  fi
	fi
      fi
    fi
  done

  # Create the help string from the array of lines. In order to get a blank
  # line this far it must have a space on it
  _po_helptext=(${(F)helptext})

  # Useful for debugging
  if (( _po_debug ))
  then
    echo "_po_tags=(${(kv)_po_tags})"
    echo "_po_types=(${(kv)_po_types})"
    echo "_po_aliases=(${(kv)_po_aliases})"
    echo "_po_arguments=(${(kv)_po_arguments})"
    echo "_po_helplines=(${(qqkv)_po_helplines[@]})"
  fi

  return 0
}

# This function generates the _arguments call used by the completion system.
# It is called when the special option --zsh-completion is passed on the
# command line to the calling program. The command is written to stdout only
# on success, and the completion system will then take that and execute it. On
# error, errors are written to stderr instead. If returning the completion
# information, parse_opts always exits with 1 in order to cause the calling
# program to exit, so the return code can not be used to signal errors
_parse_opts_generatecompletion() {
  local -a specs

  # Process each option to build a list of specifications for _arguments.
  # Careful to skip our magic --zsh-completion option
  local -a aliases excludes
  local option
  for option in ${${(k)_po_aliases}:#zsh-completion}
  do
    local spec=""

    aliases=($=_po_aliases[$option])

    # Generate excludes clause if we have any aliases. First get long option
    # aliases, then short ones, then add the clause
    excludes=()
    (( ${#aliases:#?} )) && excludes=($excludes --${^${aliases:#?}})
    (( ${#aliases:#??*} )) && excludes=($excludes -${^${aliases:#??*}})
    (( $#excludes )) && spec="$spec(${excludes:#\-})"

    # Generate the main option name section
    integer long=0
    if [[ $option == ? ]]
    then
      spec="$spec-$option"
    else
      long=1
      spec="$spec--$option"
    fi

    # Try to determine a description/completer from the type of this option
    local type="$_po_types[$option]" description="" action=""
    case $type in
      switch|noswitch|constant=*)
        # No parameters, leave blank
        ;;

      string)
        # Takes a parameter with no validation
	description="string"
	action=" "
        ;;

      integer)
        # Takes a parameter, validation for integer with optional sign
	description="integer number"
	action=" "
        ;;

      test=*)
        # Takes a parameter validated by test. Extract the test flag & try to
        # figure out the completer
        local test=${type#*=}
	case $test in
	  -[aefgkrsuwOGN]) # These are types of file
	    description="file"
	    action="_files"
	    ;;

	  -[bcdhpxLS]) # These should be special types of file but need to be looked into
	    description="file"
	    action="_files"
	    ;;

	  -[notz]) # These can't be completed
	    description="value"
	    action=" "
	    ;;

	  *) # This is not recognised
	    description="unknown"
	    action=" "
	    ;;
	esac
	;;

      *) # This is a configuration error
        echo "Invalid option type for option $option: '$type'" 1>&2
        return 1
	;;
    esac

    # If we have a long option which takes a parameter then add the '=' flag
    # to say --option=value is valid
    (( long && $#action)) && spec="$spec="

    # Add the description of the option if one was successfully extracted from the help text
    if [[ -n $_po_helplines[$option] ]]
    then
      spec="${spec}[$_po_helplines[$option]]"
    fi

    # Now add the description and completer for the parameter, if we have one
    if [[ -n $action ]]
    then
      spec="$spec:$description:$action"
    fi

    # Collect the specifications
    specs=($specs "'$spec'")
  done

  # Only output the _arguments call on success
  # -s - Allow option grouping for single letter options
  # -w - Arguments follow single letter options, one for each relevant option
  # -S - Handle -- to terminate options
  # -A - No more options after first non-option argument
  echo "_arguments -s -w -S -A '-*' $specs '*:file:_files'"

  return 0
}

# This helper function stores the given value against the given option name,
# as defined by its related tag
_parse_opts_store() {
  local _po_name="$argv[1]" _po_value="$argv[2]"

  # If tag is of the form [var] then instead assign to real variable.
  # Note possibility of clashes with our local variables here
  local _po_tag="$_po_tags[$_po_name]" 
  if [[ $_po_tag == \[*\] ]]
  then

    # If external variable then we behave according to its type
    local _po_var="${${_po_tag#\[}%\]}"
    case ${(Pt)_po_var} in
      array*)
        # An array. Append value
	eval $_po_var='(${(P)_po_var} $_po_value)'
	;;

      association*)
        # An associative array. Add option/value pair. Note option is missing
        # leading -/--
	eval $_po_var\[\$_po_name\]='$_po_value'
	;;

      *)
        # Some kind of scalar or undefined. Just assign value
        eval $_po_var='$_po_value'
        ;;
    esac
  else
    # Store the value against the real option name
    _po_results[$_po_tag]=$_po_value
  fi

  return 0
}

# This helper function for _parse_opts_handletype gets the next value for an
# option. It uses local variables in _parse_opts_handletype and so should not
# be called from elsewhere
_parse_opts_getnextvalue() {
  if (( _po_hasgivenvalue ))
  then
    # Value supplied with option so use that one first
    _po_value=$_po_givenvalue
    _po_hasgivenvalue=0
  else
    # Get the next argument as the value. Note that if single letter options
    # taking a parameter are grouped, then the parameters follow straight
    # afterwards in the respective order

    # Check there's a value to get
    if (( $#_po_argv ))
    then
      _po_value=$_po_argv[1]
      shift _po_argv
    else
      echo "Missing parameter to option '$name'" 1>&2
      return 1
    fi
  fi

  return 0
}

# This helper function handles processing of the option type. Any values it
# needs will be fetched vie _parse_opts_getnextvalue, and the appropriate
# result variable will be updated. Any validation of the values is also
# performed here
#
# NB. Locals in this function must begin _po_
_parse_opts_handletype() {
  local _po_name="$argv[1]" _po_hasgivenvalue="$argv[2]" _po_givenvalue="$argv[3]"

  local _po_type="$_po_types[$_po_name]" _po_value
  case $_po_type in
    switch)
      # Simple switch. Mark its presence
      _po_value=1
      ;;

    noswitch)
      # Reverse simple switch. Mark its presence
      _po_value=0
      ;;

    constant=*)
      # Constant to be assigned (after quote removal). eg. constant=value or constant="more values"
      _po_value=${(Q)_po_type#*=}
      ;;

    string)
      # Takes a parameter with no validation
      _parse_opts_getnextvalue || return
      ;;

    integer)
      # Takes a parameter, validation for integer with optional sign
      _parse_opts_getnextvalue || return
      if [[ $_po_value != ([-+]|)<-> ]]
      then
        echo "Invalid value for option $_po_name: '$_po_value'" 1>&2
	return 1
      fi
      ;;

    test=*)
      # Takes a parameter, validation using test. eg. test=-f
      _parse_opts_getnextvalue || return
      if eval "[[ ! ${_po_type#*=} \$_po_value ]]"
      then
        echo "Invalid value for option $_po_name: '$_po_value'" 1>&2
	return 1
      fi
      ;;

    *) # This is a configuration error
      echo "Invalid option type for option $_po_name: '$_po_type'" 1>&2
      return 1
      ;;
  esac

  _parse_opts_store $_po_name $_po_value
}

# This helper function decodes any options present in the command line
# arguments, using the pre-generated option arrays from _parse_opts_parsehelp.
# Arguments are provided in _po_argv and are removed as and when processed.
# Decoded options are returned in _po_results. Returns 1 if an error prevented
# the options from being processed, else 0
#
# NB. Locals in this function must begin _po_
_parse_opts_dooptions() {

  # Process each argument while it is an option
  while [[ $_po_argv[1] == -* ]]
  do
    local _po_option="$_po_argv[1]"
    shift _po_argv

    case $_po_option in
      --) # End of option list

        # Nothing else to do - return success
        return 0
	;;

      --*) # Long argument

      	# Extract the option name from eg. --name=value
      	local _po_name="${${_po_option#--}%%\=*}"

      	# Check to see if the option exists
      	if (( $+_po_aliases[$_po_name] ))
      	then

	  # Check to see if value was in option, ie. --name=value
	  if [[ $_po_option == *=* ]]
	  then

	    # Extract value in option and pass to type processing
	    _parse_opts_handletype $_po_name 1 ${_po_option#*=} || return
	  else

	    # Call type handling without a value
	    _parse_opts_handletype $_po_name 0 || return
	  fi
      	else
      	  echo "Invalid option: $_po_name" 1>&2
	  return 1
      	fi
	;;

      -?*) # Short option (may be grouped)

      	# Extract the list of options from eg. -jkl
      	local _po_optiongroup="${_po_option#-}"

      	# Process each letter individually
      	while [[ -n $_po_optiongroup ]]
      	do
      	  # Extract the first letter
      	  local _po_optionletter="$_po_optiongroup[1]"
	  _po_optiongroup=${_po_optiongroup#?}

      	  # Check to see if is a valid short option
      	  if (( $+_po_aliases[$_po_optionletter] ))
      	  then

	    # It is so process it as the type determines
	    _parse_opts_handletype $_po_optionletter 0 || return
      	  else
      	    echo "Invalid option: $_po_optionletter" 1>&2
      	    return 1
      	  fi
      	done
	;;

      *) # Must be a lone -
        echo "Missing option after -" 1>&2
        return 1
	;;
    esac
  done

  return 0
}

# This helper function decodes the numeric expression within an argument
# specification to return an integer value. It uses local variables in
# _parse_opts_doarguments and so should not be called from elsewhere
_parse_opts_getuse() {
  integer number="$argv[1]"
  local expression="$argv[2]"

  case $expression in
    \*) # Use default number
      _po_use=$number
      ;;

    <->) # Use fixed number
      _po_use=$expression
      ;;

    \*-<->) # Use default number minus fixed number
      (( _po_use = number - ${_po_argument#\*-} ))
      ;;

    *) # This is a configuration error
      echo "Unrecognised argument specification for option $_po_name: '$_po_argument'" 1>&2
      return 1
      ;;
  esac

  return 0
}

# This helper function decodes any arguments present in the command line after
# the options have been removed, using the pre-generated option arrays from
# _parse_opts_parsehelp. Arguments are provided in _po_argv and are removed as
# and when processed. Decoded values are returned in _po_results. Returns 1 if
# an error prevented the arguments from being processed, else 0
#
# NB. Locals in this function must begin _po_
_parse_opts_doarguments() {

  # Process each argument specification
  local _po_name
  for _po_name in ${(ok)_po_arguments}
  do
    local _po_argument="$_po_arguments[$_po_name]"

    integer _po_use=0
    case $_po_argument in
      \[*,*]) # All the remaining arguments with both minimum and maximum

        # First check the lower bound, then the upper. If both number of args
        # is within both then use that instead
        _parse_opts_getuse $#_po_argv ${${_po_argument#\[}%,*\]} || return 1
	if (( _po_use < $#_po_argv ))
	then
          _parse_opts_getuse $#_po_argv ${${_po_argument#\[*,}%\]} || return 1
	  if (( _po_use > $#_po_argv ))
	  then
            _po_use=$#_po_argv
	  fi
	fi
	;;

      \[*\]) # Fixed number of arguments. eg. [1]
        _parse_opts_getuse $#_po_argv ${${_po_argument#\[}%\]} || return 1
	;;

      *) # This is a configuration error      
        echo "Unrecognised argument specification for option $_po_name: '$_po_argument'" 1>&2
        return 1
	;;
    esac

    # Check there are a sufficient number of arguments left
    if (( $#_po_argv >= _po_use ))
    then

      # Process each of them according to the type
      repeat $_po_use
      do
        _parse_opts_handletype $_po_name 1 $_po_argv[1] || return
	shift _po_argv
      done
    else
      echo "Insufficient arguments" 1>&2
      return 1
    fi
  done

  # If there's any surplus arguments that's an error
  if (( $#_po_argv ))
  then
    echo "Too many arguments" 1>&2
    return 1
  fi

  return 0
}

# This helper function controls the overall processing
#
# NB. Locals in this function must begin _po_
_parse_opts_process() {
  local -A _po_tags _po_types _po_aliases _po_arguments _po_helplines
  local _po_helptext

  # Check for arguments. If we have one and it is not '-' then it is the help
  # string. Otherwise need to to get that from stdin
  local _po_config
  if [[ -n $argv[1] && $argv[1] != - ]]
  then
    _po_config=$argv[1]
  else
    _po_config=$(cat)
  fi

  # Parse the help string we've got to determine the type of options
  _parse_opts_parsehelp $_po_config

  # Add hooks for zsh completion system
  _po_tags[zsh-completion]="zshcompletion"
  _po_types[zsh-completion]="switch"
  _po_aliases[zsh-completion]=""

  # Perform the option recognition
  if _parse_opts_dooptions
  then

    # If success and help was requested then give it. Note that it is up to
    # the user to supply the help option before we can use it
    if (( _po_results[help] ))
    then
      echo $_po_helptext
      return 1
    fi

    # Entry point for automatic zsh completion. We always return 1 in order to
    # get the calling program to exit. The completion system knows this is not
    # an error
    if (( _po_results[zshcompletion] ))
    then
      _parse_opts_generatecompletion
      return 1
    fi

    # Perform the argument recognition
    if ! _parse_opts_doarguments
    then

      # There was an error in processing. Mention the --help option. Assumes the
      # function supplied one!
      echo "Use --help for more information" 1>&2
      return 1
    fi

  else

    # There was an error in processing. Mention the --help option. Assumes the
    # function supplied one!
    echo "Use --help for more information" 1>&2
    return 1
  fi

  return 0
}

# Parse the command line arguments to extract both long and short form options
# Usage: parse_opts <argv> <results> [<help>]
# argv    - The NAME of the array that the arguments have been copied into. Note
#           that they must have been copied; 'argv' cannot be passed here
# results - The NAME of the associative array that the decoded options are to be
#           placed in
# help    - The help text with the option descriptions encoded in it. If not
#           provided then this will be read from stdin (this allows the use of
#           a here-doc to provide the help)
# Returns 1 if an error occurred or help was given, 0 for success. If 1 is
# returned then no further action is required - it has already been reported.
# Also the source arrays will remain unchanged in this case.
#
# This function is a wrapper for _parse_opts_process to handle accessing the
# arrays in the calling function's namespace
#
# NB. Locals in this function must begin _po_
parse_opts() {

  local _po_ext_argv="$argv[1]" _po_ext_results="$argv[2]" _po_config="$argv[3]"

  # Ensure options are in a known & useful state
  emulate -L zsh
  setopt extended_glob

  # Copy current values of external arrays into our copies. This allows for
  # default state in the options, etc.
  local -a _po_argv
  local -A _po_results
  _po_argv=(${(P)_po_ext_argv})
  _po_results=("${(@Pkv)_po_ext_results}")

  # Do the work. Only update the external arrays if we succeeded
  if _parse_opts_process $_po_config
  then
    eval $_po_ext_argv='($_po_argv)'
    eval $_po_ext_results='("${(@kv)_po_results}")'
  else
    return 1
  fi

  return 0
}

parse_opts "$argv[@]"
